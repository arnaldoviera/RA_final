getwd()
dir <- getwd()
rm( list=ls() )
gc()
library(readr)
library(dplyr)
library(ggplot2)
library(tidyr)
library(alr4)
library(ISLR)
library(GGally)
library(qpcR)
library(UsingR)
library(data.table)
dir <- getwd()
data <- fread("/clinton.txt")
data <- fread(di + "/clinton.txt")
"
data <- fread("\\clinton.txt")
data <- fread("\clinton.txt")
data <- fread("/clinton.txt")
#defino la carpeta donde trabajo
setwd("C:\\Users\\vieraa\\Desktop\\Austral2021\\LABORATORIO1\\Austral2021R" )
karch_aplicacion  <- ".\\datasets\\paquete_premium_201907_ext_Arnaldo2.csv"
karch_generacion  <- ".\\datasets\\paquete_premium_201905_ext_Arnaldo2.csv"
data <- fread(".\\clinton.txt")
setwd(getwd() )
data <- fread(".\\clinton.txt")
getwd()
data <- fread("C:\\Users\\ieraa\\Desktop\\Austral2021\\LABORATORIO1\\Austral2021R\\clinton.txt")
data <- fread("C:\\Users\\vieraa\\Desktop\\Austral2021\\LABORATORIO1\\Austral2021R\\clinton.txt")
data <- fread("C:/Users/vieraa/Desktop/Austral2021/LABORATORIO1/Austral2021R/clinton.txt")
getwd()
setwd("C:/Users/vieraa/Documents/GitHub/RA_final" )   #establezco la carpeta donde voy a trabajar
data <- fread("clinton.txt")
data1<- dplyr::select(data, pje:crimen)
grafico1<-ggpairs(data1, title="correlogram with ggpairs()")
grafico2<-ggcorr(data1, nbreaks = 4, palette = "RdGy", label = TRUE, label_size = 3, label_color = "white")
mod1<-lm(pje ~ edad+ahorros+ingpc+pobreza+veteranos+mujeres+densidad+ancianos+crimen, data=data )
summary(mod1)
#analisis de residuos
PRESS(mod1)$residuals
plot(mod1)
#CME
cme <- SCE/(n-p) #igual al cuadrado de la residual SE
SCE <- deviance(mod1)
#CME
cme <- SCE/(n-p) #igual al cuadrado de la residual SE
#R2 ajustado
r2aj <- 1 - ((n-1)/(n-p)) * (1-summary(m)$r.squared)
n <- length(residuals(mod1))
p <- length(coefficients(mod1)) #incluye intercepto
#CME
cme <- SCE/(n-p) #igual al cuadrado de la residual SE
#R2 ajustado
r2aj <- 1 - ((n-1)/(n-p)) * (1-summary(m)$r.squared)
#R2 ajustado
r2aj <- 1 - ((n-1)/(n-p)) * (1-summary(mod1)$r.squared)
summary(m)$adj.r.squared
summary(mod1)$adj.r.squared
yi <- iris$Petal.Length
1 - (deviance(m) / (n-p)) / ((sum((yi - mean(yi))^2))/(n-1))
1 - (deviance(mod1) / (n-p)) / ((sum((yi - mean(yi))^2))/(n-1))
#PRESS
estpress <- sum((residuals(mod1)/(1-hatvalues(mod1)))^2) #qpcR::PRESS(m)
#Mallows CP
mcp <- SCE/(deviance(maxi)/(n-length(coefficients(maxi)))) + 2*p - n
criterios <- function(m, maxi) {
#analisis de residuos
PRESS(mod1)$residuals
plot(mod1)
SCE <- deviance(mod1)
n <- length(residuals(mod1))
p <- length(coefficients(mod1)) #incluye intercepto
#CME
cme <- SCE/(n-p) #igual al cuadrado de la residual SE
#R2 ajustado
r2aj <- 1 - ((n-1)/(n-p)) * (1-summary(mod1)$r.squared)
summary(mod1)$adj.r.squared
yi <- iris$Petal.Length
1 - (deviance(mod1) / (n-p)) / ((sum((yi - mean(yi))^2))/(n-1))
#PRESS
estpress <- sum((residuals(mod1)/(1-hatvalues(mod1)))^2) #qpcR::PRESS(m)
#Mallows CP
mcp <- SCE/(deviance(maxi)/(n-length(coefficients(maxi)))) + 2*p - n
#olsrr::ols_mallows_cp(m, maxi)
#AKAIKE
akaike <- n * log(SCE/n) + 2*p #extractAIC(m)[2]
#BIC
schwarz <- n * log(SCE/n) + p*log(n) #extractAIC(m, k = log(n))[2]
tibble(CME = cme, R2Aj = r2aj, PRESS = estpress, Cp = mcp, AIC = akaike, BIC = schwarz)
}
View(criterios)
criterios <- function(mmod1, maxi) {
#analisis de residuos
PRESS(mod1)$residuals
plot(mod1)
SCE <- deviance(mod1)
n <- length(residuals(mod1))
p <- length(coefficients(mod1)) #incluye intercepto
#CME
cme <- SCE/(n-p) #igual al cuadrado de la residual SE
#R2 ajustado
r2aj <- 1 - ((n-1)/(n-p)) * (1-summary(mod1)$r.squared)
summary(mod1)$adj.r.squared
yi <- iris$Petal.Length
1 - (deviance(mod1) / (n-p)) / ((sum((yi - mean(yi))^2))/(n-1))
#PRESS
estpress <- sum((residuals(mod1)/(1-hatvalues(mod1)))^2) #qpcR::PRESS(m)
#Mallows CP
mcp <- SCE/(deviance(maxi)/(n-length(coefficients(maxi)))) + 2*p - n
#olsrr::ols_mallows_cp(m, maxi)
#AKAIKE
akaike <- n * log(SCE/n) + 2*p #extractAIC(m)[2]
#BIC
schwarz <- n * log(SCE/n) + p*log(n) #extractAIC(m, k = log(n))[2]
tibble(CME = cme, R2Aj = r2aj, PRESS = estpress, Cp = mcp, AIC = akaike, BIC = schwarz)
}
#analisis de residuos
PRESS(mod1)$residuals
plot(mod1)
#CME
cme <- SCE/(n-p) #igual al cuadrado de la residual SE
#R2 ajustado
r2aj <- 1 - ((n-1)/(n-p)) * (1-summary(mod1)$r.squared)
summary(mod1)$adj.r.squared
yi <- iris$Petal.Length
1 - (deviance(mod1) / (n-p)) / ((sum((yi - mean(yi))^2))/(n-1))
#PRESS
estpress <- sum((residuals(mod1)/(1-hatvalues(mod1)))^2) #qpcR::PRESS(m)
#Mallows CP
mcp <- SCE/(deviance(maxi)/(n-length(coefficients(maxi)))) + 2*p - n
#Mallows CP
mcp <- SCE/(deviance(max)/(n-length(coefficients(max)))) + 2*p - n
#AKAIKE
akaike <- n * log(SCE/n) + 2*p #extractAIC(m)[2]
#BIC
schwarz <- n * log(SCE/n) + p*log(n) #extractAIC(m, k = log(n))[2]
tibble(CME = cme, R2Aj = r2aj, PRESS = estpress, Cp = mcp, AIC = akaike, BIC = schwarz)
tibble(CME = cme, R2Aj = r2aj, PRESS = estpress, Cp = mcp, AIC = akaike, BIC = schwarz)
data(data)
library(MASS)
data(data)
stepAIC(
object = lm(pje ~ 1, data = data), #punto de partida
scope = list(upper = lm(pje ~ ., data = data)), #máximo modelo posible
direction = "forward", #método de selección
trace = FALSE #para no imprimir resultados parciales
)
#mejor subconjunto
library(leaps)
mejorsub <- regsubsets(
x = pje ~ edad + ahorros + ingpc + pobreza + veteranos + mujeres + densidad + ancianos + crimen,
data = data
)
summary(mejorsub)
mejorsub_print <- summary(mejorsub)
mejorsub_print
View(mejorsub_print)
View(mejorsub)
#Técnicas paso a paso
mod_forward <- regsubsets(pje ~ edad + ahorros + ingpc + pobreza + veteranos + mujeres + densidad + ancianos + crimen, data, method = "forward")
mod_backward <- regsubsets(pje ~ edad + ahorros + ingpc + pobreza + veteranos + mujeres + densidad + ancianos + crimen, data, method = "backward")
mod_seqrep <- regsubsets (pje ~ edad + ahorros + ingpc + pobreza + veteranos + mujeres + densidad + ancianos + crimen, data, method = "seqrep")
mejorsub_print <- summary(mejorsub)
mejorsub_print
source('~/GitHub/RA_final/Trabajo Final Regresion Avanzada.R', encoding = 'UTF-8', echo=TRUE)
rm( list=ls() )
gc()
library(readr)
library(dplyr)
library(ggplot2)
library(tidyr)
library(alr4)
library(ISLR)
library(GGally)
library(qpcR)
library(UsingR)
library(data.table)
library(funModeling)
#Cargamos el dataset
#dos aca cada uno pone si ingreso de la data
#Cadauno usa su directorio
setwd("C:/Users/vieraa/Documents/GitHub/RA_final" )   #establezco la carpeta donde voy a trabajar
data <- fread("clinton.txt")
#creo un dataset sacando los estados; me pregunto, vale la pena hacer un one hot encoding con los estados?
# IRU -> A mi me parece que, si Brooklyn está siendo una observación influyente (NO outlier), quizás tenga sentido.
# De todas maneras, habría que ver cómo performan ambos modelos y quedarnos con el mejor.
# Podemos plantear ambos.
data1<- dplyr::select(data, pje:crimen)
#EDA? es necesario? o arrancamos con los modelos
# JOR -> Si, creo que es necesario hacer una introd de los que se va a analizar
# IRU -> Para conocimiento nuestro, no vamos a tener espacio para incluírlo (algo super breve)
# Arnaldo -> freq no arroja nada en concreto, qué queremos ver?
#EDA
summary(data1)
glimpse(data1)
print(status(data1))
freq(data1)
print(profiling_num(data1))
plot_num(data1)
describe(data1)
print(profiling_num(data1))
plot_num(data1)
describe(data1)
grafico1<-ggpairs(data1, title="correlogram with ggpairs()")
grafico2<-ggcorr(data1, nbreaks = 4, palette = "RdGy", label = TRUE, label_size = 3, label_color = "white")
grafico1
grafico2<-ggcorr(data1, nbreaks = 4, palette = "RdGy", label = TRUE, label_size = 3, label_color = "white")
grafico2
View(data)
View(data)
View(data)
library(psych)
multi.hist(x = data1, dcol = c("blue", "red"), dlty = c("dotted", "solid"),
main = "")
#creo modelo de regresion multiple sin modificaciones
mod1<-lm(pje ~ edad+ahorros+ingpc+pobreza+veteranos+mujeres+densidad+ancianos+crimen, data=data )
summary(mod1)
plot(mod1)
criterios <- function(mmod1, maxi) {
#analisis de residuos
PRESS(mod1)$residuals
SCE <- deviance(mod1)
n <- length(residuals(mod1))
p <- length(coefficients(mod1)) #incluye intercepto
#CME
cme <- SCE/(n-p) #igual al cuadrado de la residual SE
#R2 ajustado
r2aj <- 1 - ((n-1)/(n-p)) * (1-summary(mod1)$r.squared)
summary(mod1)$adj.r.squared
yi <- iris$Petal.Length
1 - (deviance(mod1) / (n-p)) / ((sum((yi - mean(yi))^2))/(n-1))
#PRESS
estpress <- sum((residuals(mod1)/(1-hatvalues(mod1)))^2) #qpcR::PRESS(m)
#Mallows CP
mcp <- SCE/(deviance(maxi)/(n-length(coefficients(maxi)))) + 2*p - n
#olsrr::ols_mallows_cp(m, maxi)
#AKAIKE
akaike <- n * log(SCE/n) + 2*p #extractAIC(m)[2]
#BIC
schwarz <- n * log(SCE/n) + p*log(n) #extractAIC(m, k = log(n))[2]
tibble(CME = cme, R2Aj = r2aj, PRESS = estpress, Cp = mcp, AIC = akaike, BIC = schwarz)
}
library(MASS)
data(data)
stepAIC(
object = lm(pje ~ 1, data = data), #punto de partida
scope = list(upper = lm(pje ~ ., data = data)), #mÃ¡ximo modelo posible
direction = "forward", #mÃ©todo de selecciÃ³n
trace = FALSE #para no imprimir resultados parciales
)
library(MASS)
data(data)
stepAIC(
object = lm(pje ~ 1, data = data), #punto de partida
scope = list(upper = lm(pje ~ ., data = data)), #mÃ¡ximo modelo posible
direction = "forward", #mÃ©todo de selecciÃ³n
trace = FALSE #para no imprimir resultados parciales
)
#mejor subconjunto
library(leaps)
mejorsub <- regsubsets(
x = pje ~ edad + ahorros + ingpc + pobreza + veteranos + mujeres + densidad + ancianos + crimen,
data = data
)
mejorsub_print <- summary(mejorsub)
mejorsub_print
#TÃ©cnicas paso a paso
mod_forward <- regsubsets(pje ~ edad + ahorros + ingpc + pobreza + veteranos + mujeres + densidad + ancianos + crimen, data, method = "forward")
mod_backward <- regsubsets(pje ~ edad + ahorros + ingpc + pobreza + veteranos + mujeres + densidad + ancianos + crimen, data, method = "backward")
mod_seqrep <- regsubsets (pje ~ edad + ahorros + ingpc + pobreza + veteranos + mujeres + densidad + ancianos + crimen, data, method = "seqrep")
step(object = mod1, direction = "both", trace = 1)
mod2<-lm(formula = pje ~ ahorros + ingpc + pobreza + veteranos + mujeres +
densidad + ancianos + crimen, data = data)
summary(mod2)
rm( list=ls() )
gc()
library(readr)
library(dplyr)
library(ggplot2)
library(tidyr)
library(alr4)
library(ISLR)
library(GGally)
library(qpcR)
library(UsingR)
library(data.table)
library(funModeling)
#Cargamos el dataset
#dos aca cada uno pone si ingreso de la data
#Cadauno usa su directorio
setwd("C:/Users/vieraa/Documents/GitHub/RA_final" )   #establezco la carpeta donde voy a trabajar
data <- fread("clinton.txt")
#creo un dataset sacando los estados; me pregunto, vale la pena hacer un one hot encoding con los estados?
# IRU -> A mi me parece que, si Brooklyn está siendo una observación influyente (NO outlier), quizás tenga sentido.
# De todas maneras, habría que ver cómo performan ambos modelos y quedarnos con el mejor.
# Podemos plantear ambos.
data1<- dplyr::select(data, pje:crimen)
#EDA
summary(data1)
glimpse(data1)
print(status(data1))
freq(data1) # Arnaldo -> freq no arroja nada en concreto, qué queremos ver?
print(profiling_num(data1))
plot_num(data1)
describe(data1)
grafico1<-ggpairs(data1, title="correlogram with ggpairs()")
grafico1
grafico2<-ggcorr(data1, nbreaks = 4, palette = "RdGy", label = TRUE, label_size = 3, label_color = "white")
grafico2
library(psych)
multi.hist(x = data1, dcol = c("blue", "red"), dlty = c("dotted", "solid"),
main = "")
#creo modelo de regresion multiple sin modificaciones
mod1<-lm(pje ~ edad+ahorros+ingpc+pobreza+veteranos+mujeres+densidad+ancianos+crimen, data=data )
summary(mod1)
plot(mod1)
#analisis de residuos
PRESS(mod1)$residuals
SCE <- deviance(mod1)
n <- length(residuals(mod1))
p <- length(coefficients(mod1)) #incluye intercepto
#CME
cme <- SCE/(n-p) #igual al cuadrado de la residual SE
#R2 ajustado
r2aj <- 1 - ((n-1)/(n-p)) * (1-summary(mod1)$r.squared)
summary(mod1)$adj.r.squared
yi <- iris$Petal.Length
1 - (deviance(mod1) / (n-p)) / ((sum((yi - mean(yi))^2))/(n-1))
#PRESS
estpress <- sum((residuals(mod1)/(1-hatvalues(mod1)))^2) #qpcR::PRESS(m)
#Mallows CP
mcp <- SCE/(deviance(maxi)/(n-length(coefficients(maxi)))) + 2*p - n
#olsrr::ols_mallows_cp(m, maxi)
#AKAIKE
akaike <- n * log(SCE/n) + 2*p #extractAIC(m)[2]
#BIC
schwarz <- n * log(SCE/n) + p*log(n) #extractAIC(m, k = log(n))[2]
tibble(CME = cme, R2Aj = r2aj, PRESS = estpress, Cp = mcp, AIC = akaike, BIC = schwarz)
}
library(MASS)
data(data)
stepAIC(
object = lm(pje ~ 1, data = data), #punto de partida
scope = list(upper = lm(pje ~ ., data = data)), #mÃ¡ximo modelo posible
direction = "forward", #mÃ©todo de selecciÃ³n
trace = FALSE #para no imprimir resultados parciales
)
#mejor subconjunto
library(leaps)
mejorsub <- regsubsets(
x = pje ~ edad + ahorros + ingpc + pobreza + veteranos + mujeres + densidad + ancianos + crimen,
data = data
)
mejorsub_print <- summary(mejorsub)
mejorsub_print
#TÃ©cnicas paso a paso
mod_forward <- regsubsets(pje ~ edad + ahorros + ingpc + pobreza + veteranos + mujeres + densidad + ancianos + crimen, data, method = "forward")
mod_backward <- regsubsets(pje ~ edad + ahorros + ingpc + pobreza + veteranos + mujeres + densidad + ancianos + crimen, data, method = "backward")
mod_seqrep <- regsubsets (pje ~ edad + ahorros + ingpc + pobreza + veteranos + mujeres + densidad + ancianos + crimen, data, method = "seqrep")
step(object = mod1, direction = "both", trace = 1)
mod2<-lm(formula = pje ~ ahorros + ingpc + pobreza + veteranos + mujeres +
densidad + ancianos + crimen, data = data)
summary(mod2)
#Criterios de selecciÃ³n de modelos
resumen$cp
resumen$adjr2
resumen$bic
#GrÃ¡ficos para comparar ajustes
plot(mejorsub, scale = "Cp")
plot(mejorsub, scale = "adjr2")
plot(mejorsub, scale = "bic")
#TÃ©cnicas paso a paso
regsubsets(Sepal.Length ~ Sepal.Width + Petal.Length + Petal.Width, iris, method = "forward")
regsubsets(Sepal.Length ~ Sepal.Width + Petal.Length + Petal.Width, iris, method = "backward")
regsubsets(Sepal.Length ~ Sepal.Width + Petal.Length + Petal.Width, iris, method = "seqrep")0
criterios
## Arnaldo => esto que sigue sirve para algo?
criterios <- function(mmod1, maxi) {
#analisis de residuos
PRESS(mod1)$residuals
SCE <- deviance(mod1)
n <- length(residuals(mod1))
p <- length(coefficients(mod1)) #incluye intercepto
#CME
cme <- SCE/(n-p) #igual al cuadrado de la residual SE
#R2 ajustado
r2aj <- 1 - ((n-1)/(n-p)) * (1-summary(mod1)$r.squared)
summary(mod1)$adj.r.squared
yi <- iris$Petal.Length
1 - (deviance(mod1) / (n-p)) / ((sum((yi - mean(yi))^2))/(n-1))
#PRESS
estpress <- sum((residuals(mod1)/(1-hatvalues(mod1)))^2) #qpcR::PRESS(m)
#Mallows CP
mcp <- SCE/(deviance(maxi)/(n-length(coefficients(maxi)))) + 2*p - n
#olsrr::ols_mallows_cp(m, maxi)
#AKAIKE
akaike <- n * log(SCE/n) + 2*p #extractAIC(m)[2]
#BIC
schwarz <- n * log(SCE/n) + p*log(n) #extractAIC(m, k = log(n))[2]
tibble(CME = cme, R2Aj = r2aj, PRESS = estpress, Cp = mcp, AIC = akaike, BIC = schwarz)
}
criterios
